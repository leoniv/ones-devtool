#!/usr/bin/env ruby
# encoding: utf-8

$:.unshift(File.join(File.dirname(__FILE__), %w[.. lib]))

require 'ones_devtool'
require 'getoptlong'
require 'fileutils'
require 'git'
require 'logger'
require 'net/ssh'

DEFPATH = "~/repo"
DEFUSER= "git"

opts = GetoptLong.new(
  [ '--help', '-h', GetoptLong::NO_ARGUMENT ],
  [ '--version', '-v', GetoptLong::NO_ARGUMENT],
  [ '--host','-H', GetoptLong::REQUIRED_ARGUMENT ],
  [ '--pkgname','-p', GetoptLong::REQUIRED_ARGUMENT ],
  [ '--pass','-P', GetoptLong::REQUIRED_ARGUMENT ],
  [ '--licfile','-l', GetoptLong::REQUIRED_ARGUMENT ]
)

params = {:pkgname=>"",
         :licfile=>"",
         :host=>"",
         :pass=>""
}

reqparams=[:pkgname]

def usage
  puts "Использование: #{$0.split("/").last} [[--help][--version]] [--licfile=<path>] --host <[user@]host[/path]> --pkgname <name>
  Утилита создаёт и инициирует репозитарий git для 1С разработки.
  Репозиторий создаётся в текущей директории. 
  Имя репозитария расчитывается из имени пакета по правилам:
   * Символы нижнего подчеркивания '_' удваиваются
   * Символы тире '-' заменяются на символы нижнего подчеркивания '_'   
   * Символы точка '.' заменяются на символы тире '-'
  Соединение с узлом <user@host> по протоколу ssh.
   
  -p | --pkgname <name>   - имя пакета ПО. Может содержать символы [-a-zA-z_.].
  -H | --host <[user@]host[\/path]> -
                              если указан узел где будет создан центральный репозитарий.
                              [user@] - имя пользователя. Опционально по умолчанию 'git'
                              [/path] - путь где будет создан репозиторий. Опционально по умолчанию '~/repo'
  -P | --pass <pasword>   - пароль для пользователя на узле host. Имеет смысл с --host.
  -l | --licfile <path>   - путь к файлу содержащему текст лицензии.
                            Если не задан файл license не будет создан.
  -v | --version          - покажет версию утилиты. 
  -h | --help             - покажет это сообщение"
end

def version
  puts "Версия: #{Version::VERSION}"
end

def validpkgname(pkgname)
  raise "--pkgname <#{pkgname}> имеет запрещённые символы" if pkgname=~/[^-0-9a-zA-z_.]/
  pkgname
end

def getopt(opts,prams)
  begin
  opts.each do |opt, arg|
    case opt
      when '--help'
        usage
        exit 0
      when '--version'
        version
        exit 0
      when '--pkgname'
        begin
          prams[:pkgname] = validpkgname(arg)
        rescue Exception => e
          abort e.message+"\n Имя пакета ПО. Может содержать символы [-a-zA-z_.]."
        end
      when '--licfile'
        if File.exist?(arg) and File.file?(arg)
          prams[:licfile] = arg
        else
          abort "--licfile <#{arg}> не существует."
        end      
      when '--host'
      prams[:host] = arg
      when '--pass'
      prams[:pass] = arg   
    end
  end
  rescue SystemExit => e
    exit e.status
  rescue GetoptLong::MissingArgument => e
    $stderr.write("Помощь ключ --help")
    exit 1
  end
end  

#Обязательные прааметры
def checkparam(reqparams,params)
  reqparams.each{|pname|
    abort "Не задан параметр --#{pname.to_s}. Помощь ключ --help" if params[pname].length == 0
  }
end  

def getreponame(pkgname)
  result = pkgname.gsub(/_/){|s| s*2}
  result = result.gsub(/-/){|s| "_"}
  result = result.gsub(/\./){|s| "-"}
  result
end  

#Programm

getopt(opts,params)
checkparam(reqparams,params)

if params[:host].length>0
  host = params[:host].split("@")
  
  if host.length == 2
    user,path = host[0],host[1]
  else 
    user = DEFUSER
    path = host[0]   
  end 
  
  path = path.split("/")
  host = path[0]
  if path.length > 1
    path.delete_at(0)
    path = "#{path[0]=="~" ? "" : "/"}#{path.join("/")}"
  else
    path = DEFPATH  
  end
end

reponame = getreponame(params[:pkgname])
  
#Пытаемся соедениться по SSH
if params[:host].length>0
  ssh_opt = {};
  ssh_opt[:password]=params[:pass] if params[:pass].length>0
  begin 
    Net::SSH.start(host,user,ssh_opt)do|ssh|
      #tst bin git
      ssh.exec("git")do |ch, stream, data|
          if stream == :stderr
            raise "GIT: #{data} возможно не установлен git."
          end
      end
     #Test writable path 
      ssh.exec("touch #{path}/.tmp && rm #{path}/.tmp")do |ch, stream, data|
          if stream == :stderr
            raise "EXEC: #{data} директория #{path} или не существует или не доступна для записи."
          end
      end
      #Test if repo exists 
       ssh.exec("test -e #{path}/#{reponame}.git && echo -e \"#{path}/#{reponame}.git exist\">&2")do |ch, stream, data|
           if stream == :stderr
             raise "TEST: #{data} директория #{path}/#{reponame}.git существует."
           end
       end
     end
  rescue Exception => e
    abort "SSH ERROR: #{e.class} <#{e.message}> user=#{user} on host=#{host}"
  end    
end

#Создаём каталог для локальный репозитарий
abort "Каталог существует #{reponame}"  if File.exist?(reponame)
Dir.mkdir(reponame)
#Создаём pkgname
File.open(File.join(reponame,"pkgname"),"w",File::CREAT){|f| f.write(params[:pkgname])}
#Копируем licfile
FileUtils.cp(params[:licfile],File.join(reponame,"license")) if File.exist?(params[:licfile])    
#Создаём README
README = File.join(reponame,"README")
README_TEXT="#Напишите информацию о пакете:\n#Назначение\n#Сайт проекта\n#Завистмости\n#Где получать обновления\n#Порядок установки"
File.open(README,"w",File::CREAT){|f| f.write("Пакет: #{params[:pkgname]}\n#{README_TEXT}")}
system("$EDITOR #{README}")
#Создаём .gitignore
IGNORE="*.cf\n*.epf\n*.erf\n*tmp\n*~"
File.open(File.join(reponame,".gitignore"),"w",File::CREAT){|f| f.write("#{IGNORE}")}
#mode 664
FileUtils.chmod(0664,Dir.glob("#{reponame}/*"))    
#Создаём gitrepo
FileUtils.chdir(reponame)  
git = Git.init()
git.add
git.commit('zero point')
puts "Создан локальный репозитарий #{reponame}"
#Создаём центральный репозиторий
if params[:host].length>0
  puts "Создаю репозитарий #{path}/#{reponame}.git on host=#{host}"
  ssh_opt = {};
  ssh_opt[:password]=params[:pass] if params[:pass].length>0
  begin 
    Net::SSH.start(host,user,ssh_opt)do|ssh|
      out=ssh.exec("cd #{path} && mkdir #{path}/#{reponame}.git && cd #{reponame}.git && git init --bare")do |ch, stream, data|
          if stream == :stderr
            raise "CREATE REPO: #{data}."
          else
           puts data
          end
        end
    end
    puts "PUSH in to #{host}/#{path}/#{reponame}.git"
    git.add_remote("origin","#{user}@#{host}:#{path}/#{reponame}.git")
    git.push     
  rescue Exception => e
    abort "SSH ERROR: #{e.class} <#{e.message}> user=#{user} on host=#{host}"
  end
end
puts "Ok. By..."



  




