//**********************************************************************************
//  Тест доработки конфигурации
//  
//  О тестировании можно прочесть здесь:
//	http://rm.asscode.ru/projects/ru-asscode-ones-devtool/wiki/Unit-тестирование_объектов_МД
//
//  Respect: авторам проекта V8Unpack https://www.assembla.com/wiki/show/V8Unpack/. 
//
//  Copyright © 2013 Leonid Vlasov (leo@asscode.ru)
//
//	Данная лицензия разрешает лицам, получившим копию данного программного 
//	обеспечения и сопутствующей документации (в дальнейшем именуемыми «Программное 
//	Обеспечение»), безвозмездно использовать Программное Обеспечение без ограничений, 
//	включая неограниченное право на использование, копирование, изменение, 
//	добавление, публикацию, распространение, сублицензирование и/или продажу копий 
//	Программного Обеспечения, также как и лицам, которым предоставляется данное 
//	Программное Обеспечение, при соблюдении следующих условий:
//
//	Указанное выше уведомление об авторском праве и данные условия должны быть 
//	включены во все копии или значимые части данного Программного Обеспечения.
//
//	ДАННОЕ ПРОГРАММНОЕ ОБЕСПЕЧЕНИЕ ПРЕДОСТАВЛЯЕТСЯ «КАК ЕСТЬ», БЕЗ КАКИХ-ЛИБО 
//	ГАРАНТИЙ, ЯВНО ВЫРАЖЕННЫХ ИЛИ ПОДРАЗУМЕВАЕМЫХ, ВКЛЮЧАЯ, НО НЕ ОГРАНИЧИВАЯСЬ 
//	ГАРАНТИЯМИ ТОВАРНОЙ ПРИГОДНОСТИ, СООТВЕТСТВИЯ ПО ЕГО КОНКРЕТНОМУ НАЗНАЧЕНИЮ И 
//	ОТСУТСТВИЯ НАРУШЕНИЙ ПРАВ. НИ В КАКОМ СЛУЧАЕ АВТОРЫ ИЛИ ПРАВООБЛАДАТЕЛИ НЕ НЕСУТ 
//	ОТВЕТСТВЕННОСТИ ПО ИСКАМ О ВОЗМЕЩЕНИИ УЩЕРБА, УБЫТКОВ ИЛИ ДРУГИХ ТРЕБОВАНИЙ ПО 
//	ДЕЙСТВУЮЩИМ КОНТРАКТАМ, ДЕЛИКТАМ ИЛИ ИНОМУ, ВОЗНИКШИМ ИЗ, ИМЕЮЩИМ ПРИЧИНОЙ ИЛИ 
//	СВЯЗАННЫМ С ПРОГРАММНЫМ ОБЕСПЕЧЕНИЕМ ИЛИ ИСПОЛЬЗОВАНИЕМ ПРОГРАММНОГО ОБЕСПЕЧЕНИЯ 
//	ИЛИ ИНЫМИ ДЕЙСТВИЯМИ С ПРОГРАММНЫМ ОБЕСПЕЧЕНИЕМ.
//
//************************************************************************************

////////////////////////////////////////////////////////
// ПИШЕМ ТЕСТЫ ТОЛСТОГО КЛИЕНТА ЗДЕСЬ ->

#Область ТЕСТЫ_ТОЛСТЫЙ_КЛИЕНТ
Функция ЗапускТестовНаТолстомКлиенте(arg)
	StartProtocol("utest");
//ВЫЗЫВАЕМ ТЕСТОВЫЕ МЕТОДЫ ->	
	ДемострационныйТестТолстыйКлиент(arg);
//TODO написать тесты примерно так:

	//ПревыйСерверныйТест();
	//....
	//ПоследнийСерверныйТест();
	
//<- ВЫЗЫВАЕМ ТЕСТОВЫЕ МЕТОДЫ	
	Возврат TestProtocol(true);	
КонецФункции


#КонецОбласти

//<- ПИШЕМ ТЕСТЫ ТОЛСТОГО КЛИЕНТА ЗДЕСЬ
////////////////////////////////////////////////////////


////////////////////////////////////////////////////////
// TestEngine -> 

#Область TestEngine_ПРИМЕРЫ

Процедура ДемострационныйТестТолстыйКлиент(arg)
//ПРИМЕРЫ
// CallTrace - строка содержащая идентификатор места вызова функции Assert*. По этому идентификатору ищем строку в котрой тест провален.
//             При сравнении значений коллекций - CallTrace - покажет элемент коллекции который вызвал провал теста
//1) Проверка значений специальных типов
	CallTracePef="ДемострационныйТестКлиент()";
	MessPref="Демострационный тест. ";
	AssertTrue(MessPref+"Значение Истина",CallTracePef+"#10",Истина);
	AssertFalse(MessPref+"Значение Ложь",CallTracePef+"#15",Ложь);
	AssertNull(MessPref+"Значение Null",CallTracePef+"#16",Null);
	AssertNotNull(MessPref+"Значение НЕ Null",CallTracePef+"#16",Неопределено);
	AssertUndefined(MessPref+"Значение Неопределено",CallTracePef+"#17",Неопределено);
//2) Тест значений примитивных типов
    Число1 = 10;
    Число2 = 10;
	AssertEquals(MessPref+"Значения равны",CallTracePef+"#20",Число1,Число2);
	
	Дата1 = '00010101';
	Дата2 = '00010101';
	AssertEquals(MessPref+"Значения равны",CallTracePef+"#21",Дата1,Дата2);
	
	Строка1 = "Сравнивается без учета регистра";
	Строка2 = "Сравнивается без учета регистра";
	AssertEquals(MessPref+"Значения равны",CallTracePef+"#22",ВРег(Строка1),НРег(Строка2));
	
//3) Тест значений системных перечислений
	СП1 = ВидДвиженияБухгалтерии.Дебет;
	СП2 = ВидДвиженияБухгалтерии.Дебет;
	AssertEquals(MessPref+"Значения равны",CallTracePef+"#22",СП1,СП2);
	
//4) Тест значений универсальных коллекций
////a) КлючИЗначение
    C1=Новый Структура("Ключ1",100);
	Для Каждого с из C1 Цикл
		КЗ1 = с;
	КонецЦикла;	
    C2=Новый Структура("Ключ1",100);
	Для Каждого с из C2 Цикл
		КЗ2 = с;
	КонецЦикла;	
	AssertEquals(MessPref+"Значения равны",CallTracePef+"#22",КЗ1,КЗ2);
////б) Структура
    C1=Новый Структура("Ключ1,Ключ2,Ключ3",100,200,300);
	Для Каждого с из C1 Цикл
		КЗ1 = с;
	КонецЦикла;	
    C2=Новый Структура("Ключ1,Ключ2,Ключ3",100,200,300);
	Для Каждого с из C2 Цикл
		КЗ2 = с;
	КонецЦикла;	
	AssertEquals(MessPref+"Значения равны",CallTracePef+"#23",C1,C2);
////в) Соответствие
    CO1=Новый Соответствие;
	CO1.Вставить("Ключ 1",100);
	CO1.Вставить("Структура 1",Новый Структура("Ключ1,Ключ2,Ключ3",100,200,300));
    CO2=Новый Соответствие;
	CO2.Вставить("Ключ 1",100);
	CO2.Вставить("Структура 1",Новый Структура("Ключ1,Ключ2,Ключ3",100,200,300));
	AssertEquals(MessPref+"Значения равны",CallTracePef+"#24",CO1,CO2);
////г) Таблица значений 
	ТЗ1 = Новый ТаблицаЗначений;
	ТЗ1.Колонки.Добавить("К1",Новый ОписаниеТипов("Строка"));
	ТЗ1.Колонки.Добавить("К2",Новый ОписаниеТипов("Строка"));
	ТЗ1.Колонки.Добавить("К3",Новый ОписаниеТипов("Строка"));
	Для К=0 по 10 Цикл
		НС = ТЗ1.Добавить();
		НС[0] = К;
		НС[1] = К*2;
		НС[2] = К*3;
	КонецЦикла;	
	ТЗ2 = Новый ТаблицаЗначений;
	ТЗ2.Колонки.Добавить("К1",Новый ОписаниеТипов("Строка"));
	ТЗ2.Колонки.Добавить("К2",Новый ОписаниеТипов("Строка"));
	ТЗ2.Колонки.Добавить("К3",Новый ОписаниеТипов("Строка"));
	Для К=0 по 10 Цикл
		НС = ТЗ2.Добавить();
		НС[0] = К;
		НС[1] = К*2;
		НС[2] = К*3;
	КонецЦикла;	
    AssertEquals(MessPref+"Значения равны",CallTracePef+"#25",ТЗ1,ТЗ2);

////д) Массив - сравнивается с учетом порядка следования элементов.
	А1 = Новый Массив;
	А2 = Новый Массив;
	Для К=0 по 10 Цикл
		А1.Добавить(К);
		А2.Добавить(К);
	КонецЦикла;	
	AssertEquals(MessPref+"Значения равны",CallTracePef+"#25",А1,А2);
	
////е) Дерево значений.	
	ДЗ1 = Новый ДеревоЗначений;
	ДЗ1.Колонки.Добавить("К1",Новый ОписаниеТипов("Строка"));
	ДЗ1.Колонки.Добавить("К2",Новый ОписаниеТипов("Строка"));
	ДЗ1.Колонки.Добавить("К3",Новый ОписаниеТипов("Строка"));
	ДЗ2 = Новый ДеревоЗначений;
	ДЗ2.Колонки.Добавить("К1",Новый ОписаниеТипов("Строка"));
	ДЗ2.Колонки.Добавить("К2",Новый ОписаниеТипов("Строка"));
	ДЗ2.Колонки.Добавить("К3",Новый ОписаниеТипов("Строка"));
	
	ГСЧ = Новый ГенераторСлучайныхЧисел(100);
	
	Для К=0 По ГСЧ.СлучайноеЧисло(2,5) Цикл
		НС1 = ДЗ1.Строки.Добавить();
		НС1.К1 = Строка(ГСЧ.СлучайноеЧисло(100,10000));
		НС1.К2 = Строка(ГСЧ.СлучайноеЧисло(100,10000));
		НС1.К3 = Строка(ГСЧ.СлучайноеЧисло(100,10000));
		НС2 = ДЗ2.Строки.Добавить();
		НС2.К1 = НС1.К1;
		НС2.К2 = НС1.К2;
		НС2.К3 = НС1.К3;
		Для Л=0 по ГСЧ.СлучайноеЧисло(2,5) Цикл
			НС11 = НС1.Строки.Добавить();
			НС11.К1 = Строка(ГСЧ.СлучайноеЧисло(100,10000));
			НС11.К2 = Строка(ГСЧ.СлучайноеЧисло(100,10000));
			НС11.К3 = Строка(ГСЧ.СлучайноеЧисло(100,10000));
			НС22 = НС2.Строки.Добавить();
			НС22.К1 = НС11.К1;
			НС22.К2 = НС11.К2;
			НС22.К3 = НС11.К3;
			Для М=0 по ГСЧ.СлучайноеЧисло(2,5) Цикл
				НС111 = НС11.Строки.Добавить();
				НС111.К1 = Строка(ГСЧ.СлучайноеЧисло(100,10000));
				НС111.К2 = Строка(ГСЧ.СлучайноеЧисло(100,10000));
				НС111.К3 = Строка(ГСЧ.СлучайноеЧисло(100,10000));
				НС222 = НС22.Строки.Добавить();
				НС222.К1 = НС111.К1;
				НС222.К2 = НС111.К2;
				НС222.К3 = НС111.К3;
			КонецЦикла;
		КонецЦикла;
	КонецЦикла;
	AssertEquals(MessPref+"Значения равны",CallTracePef+"#25",ДЗ1,ДЗ2);
	
	

//5) Тест исключения. Выполняется в два этапа.
//// Этап первый. Ожидание исключения определённого типа. 
////              Тип исключения определяется по вхождению строки ExpectedExeption в строку ActualExeption.Description 
	ЗначениеДоИсключения=неопределено;
	Попытка 
		raise "Exseption";
		ЗначениеДоИсключения=100 ;
	Исключение	
		AssertRaise("Демострационный тест",CallTracePef+"#30","Exseption",ИнформацияОбОшибке());
	КонецПопытки;	
//// Этап втрой. Контроль того, что исключение было вызвано. Для этого контролируем значение
///              контрольной переменной которой будет присвоено значение если исключение не было вызвано 
	AssertUndefined("Демострационный тест",CallTracePef+"#40",ЗначениеДоИсключения);
	
//6) Сравнение значений типа ОписаниеТипов
    МТ = Новый Массив;
	МТ.Добавить(Тип("Строка"));
	МТ.Добавить(Тип("Null"));
	МТ.Добавить(Тип("ГенераторСлучайныхЧисел"));
	ОТ1 = Новый ОписаниеТипов(МТ,,,Новый КвалификаторыЧисла(10,2,ДопустимыйЗнак.Любой)
								  ,Новый КвалификаторыСтроки(1000,ДопустимаяДлина.Переменная)
								  ,Новый КвалификаторыДаты(ЧастиДаты.Дата)
								  );
								  
	ОТ2 = Новый ОписаниеТипов(МТ,,,Новый КвалификаторыЧисла(10,2,ДопустимыйЗнак.Любой)
								  ,Новый КвалификаторыСтроки(1000,ДопустимаяДлина.Переменная)
								  ,Новый КвалификаторыДаты(ЧастиДаты.Дата)
							  );
	AssertEquals("Демострационный тест",CallTracePef+"#50",ОТ1,ОТ2);
//7) Тест с созданием объектов в БД								  
////a) Поготовка к тесту создание объектов в БД
	МассивСсылок = ДемострационныйТестСервер_ПодготовитьОбъекты(RefArray());
////б) Выполнение тестов в защищенном блоке
	Попытка
		AssertEquals("Демострационный тест",CallTracePef+"#51",МассивСсылок[1],МассивСсылок[1]);
	Исключение
////в) Тест провален
//////в.1) Удаление созданных объектов
		ClearOjects(МассивСсылок);
//////в.2) Прерываем тест
		ВызватьИсключение ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
	КонецПопытки;	
////г) Тест пройден
//////г.1) Удаление созданных объектов
		ClearOjects(МассивСсылок);
		
//8) Тест с созданием записей регистров в БД								  
////a) Поготовка к тесту создание записей регистра в БД
	RecordSetArray = ДемострационныйТестСервер_ПодготовитьНаборыЗаписей(RecordSetArray());
////б) Выполнение тестов в защищенном блоке
	Попытка
		AssertEquals("Демострационный тест",CallTracePef+"#52",RecordSetArray[0].Count(),RecordSetArray[1].Count());
	Исключение
////в) Тест провален
//////в.1) Удаление созданных записей из БД
		ClearRecordSet(RecordSetArray);
//////в.2) Прерываем тест
		ВызватьИсключение ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
	КонецПопытки;	
////г) Тест пройден
//////г.1) Удаление созданных записей из БД
		ClearRecordSet(RecordSetArray);
конецПроцедуры	

функция ДемострационныйТестСервер_ПодготовитьОбъекты(RefArray)
	Спр2_1 = Справочники.Справочник2.СоздатьЭлемент();
	Спр2_1.Наименование = "Спр2_1";
// Для записи объекта используем вызов WriteObject()
// WriteObject() добавляет параметр TetsName=TestName() 
// в структуру ДополнительныеСвойства объекта. При этом
// в обработчиках (на пример "При записи") объекта 
// по наличию и значению свойства ДополнительныеСвойства.TetsName
// можно выплнять некотрые действия.
// WriteObject() помещает ссылку на записаный объект на голову(index=0)
// массива RefArray. Массив RefArray используется для удаления созданных,
// во время теста, объектов - вызов ClearOjects().
	WriteObject(Спр2_1,RefArray);
	Спр2_2 = Справочники.Справочник2.СоздатьЭлемент();
	Спр2_2.Наименование = "Спр2_2";
	WriteObject(Спр2_2,RefArray);
	Возврат RefArray;
КонецФункции

функция ДемострационныйТестСервер_ПодготовитьНаборыЗаписей(RecordSetArray)
    RecordSet1 = РегистрыСведений.Test.СоздатьНаборЗаписей();
    RecordSet2 = РегистрыСведений.Test.СоздатьНаборЗаписей();
	Для К=0 По 10 Цикл
		Rec1 = RecordSet1.Добавить();
		Rec1.Измерение1 = "И1_"+Строка(К);
		Rec1.Ресурс1 = "Р1_"+Строка(К);
		Rec1.Реквизит1 = "Р1_"+Строка(К);
		Rec2 = RecordSet2.Добавить();
		Rec2.Измерение1 = "И1_"+Строка(К+100);
		Rec2.Ресурс1 = "Р1_"+Строка(К+100);
		Rec2.Реквизит1 = "Р1_"+Строка(К+100);
	КонецЦикла;	
// Для записи набора записей независимого регистра используем вызов WriteRecordSet()
// WriteRecordSet() добавляет параметр TetsName=TestName() 
// в структуру ДополнительныеСвойства набора записей. При этом
// в обработчиках (на пример "При записи") набора записей 
// по наличию и значению свойства ДополнительныеСвойства.TetsName
// можно выплнять некотрые действия.
// WriteRecordSet() помещает ссылку на записаный объект на голову(index=0)
// массива RecordSetArray. Массив RecordSetArray используется для удаления созданных,
// во время теста, записей регистра - вызов ClearRecordSet().
	WriteRecordSet(RecordSet1,RecordSetArray);
	WriteRecordSet(RecordSet2,RecordSetArray);
	Возврат RecordSetArray;
КонецФункции


#КонецОбласти

#Область TestEngine_СЛУЖЕБНЫЕ_ЗАПУСК_ТЕСТОВ_ДЛЯ_ОБЫЧНОГО_ПРИЛОЖЕНИЯ
////////////////////////////////////////////////////////
//  МЕТОДЫ ИЗ ШАБЛОНА
Процедура TestНажатие(Элемент)
	ЭтотТест = ВнешниеОбработки.Создать(ЭтотОбъект.ИспользуемоеИмяФайла).ПолучитьФорму("MainOrdinary");
	ЭтотТест.pwd = pwd;
	ЭтотТест.usr = usr;
	ЭтотТест.Открыть();
	Закрыть();
	Сообщить(ЭтотТест.Test());
КонецПроцедуры           

//Точка входа для запуска тестов в режиме обычное приложение
function Test(arg=undefined) export
	result = "<testcase testname='"+TestName()+"' time='"+ProtocolDateFormat()+"'>";
	result =  result +"
	|"+ТестКорневогоМодуля(arg); //На толстом клиенте
	result = result +"
	|"+ЗапускТестовНаСервере(arg); //Запуск тестов из модуля объекта на сервере
	result = result +"
	|"+ЗапускТестовНаТолстомКлиенте(arg); //Запуск тестов из модуля объекта на сервере
	return result+"
	|</testcase>";
endfunction	                        

функция СтрокаСоединения()
	СтрокаСоединения_ = СтрокаСоединенияИнформационнойБазы()+"pwd="""+pwd+""";usr="""+usr+"""";
	Возврат СтрокаСоединения_;
КонецФункции	

Функция ЗапускТестовНаСервере(arg)
	Если СтрЧислоВхождений(СтрокаСоединенияИнформационнойБазы(),"Srvr=")=1 Тогда
		СтрокаСоед = СтрокаСоединения();
		COMConnector = Новый COMObject("V83.COMConnector");
	    conn = COMConnector.Connect(СтрокаСоед);
		object_test = conn.ВнешниеОбработки.Создать(ЭтотОбъект.ИспользуемоеИмяФайла);
		result = "
		|"+object_test.ТестКорневогоМодуля(arg); //Запуск на сервере
		result = result +"
		|"+object_test.ТестыСервера(arg); //Запуск на сервере
		conn = Неопределено;
		return result;
	Иначе
		result = "
		|"+ТестыСервера(arg); //Запуск на толстом клиенте в файловом варианте
		return result;
	КонецЕсли;	
КонецФункции	

Процедура UsrПриИзменении(Элемент)
	СтрокаСоединения();
КонецПроцедуры

Процедура ПриОткрытии()
	СтрокаСоединения();
КонецПроцедуры
#КонецОбласти

// <- TestEngine 
////////////////////////////////////////////////////////



